namespace ChainOfResponsibility
{
	// Поведенческие паттерны

	/*
	 * Здесь название говорит само за себя: при реализации данного паттерна у нас имеется некая цепочка обработчиков, по которой последовательно передаются запросы. 
	 * При этом каждое звено цепочки (каждый обработчик) решает, может ли он обработать запрос сам, или стоит его передать дальше по цепи.
	 */
	// Паттерн Chain of responsibility позволяет избежать жесткой привязки отправителя запроса к получателю.
	/*
	 * Признаки того, что мы можем использовать цепочку:
	 * Имеется более одного объекта, который способен обрабатывать запрос.
	 * Нам нужно, чтобы запрос был обработан одни или несколькими объектами, но точно не определено, кем именно.
	 * Если у нас динамически задаётся набор объектов.
	 * 
	 * Здесь использование цепочки обязанностей дает нам такие преимущества:
	 * Связи между объектами будут ослаблены. Отправитель и получатель запросов не знают друг о друге ничего. 
	 * Клиенту же неизвестна цепочка объектов, какие объекты её составляют и как запрос в ней передаётся.
	 * Можно легко добавлять новые объекты, реализующие общий интерфейс.
	 * В то же время у паттерна есть один недостаток: 
	 * никто не гарантирует, что запрос будет обработан в итоге. Если необходимый обработчик не найден в цепочке, запрос просто покидает цепочку и остается необработанным.
	 */

	class Program
	{
		/*
		 * Теперь давайте попробуем реализовать более жизненный пример.
		 * Мы — банковский сервис, и должны уведомить человека об операции на его счету любым доступным способом. 
		 * У человека (клиента) может быть предусмотрено несколько способов уведомления (SMS, звонок, электронная почта), но нам неважно, какой из них использовать.
		 * 
		 * Приступим к реализации.
		 */

		static void Main(string[] args)
		{
			// Создадим базовый класс обработчика: NotificationHandler.cs

			// И отдельные обработчики для каждого из видов уведомлений: EmailNotificationHandler.cs, SmsNotificationHandler.cs, VoiceNotificationHandler.cs

			// Теперь создадим класс-получатель: Receiver.cs

			// И применим в итоговой реализации: 
			Receiver receiver = new Receiver(false, true, true);

			NotificationHandler emailNotificationHandler = new EmailNotificationHandler();
			NotificationHandler voiceNotificationHandler = new VoiceNotificationHandler();
			NotificationHandler smsNotificationHandler = new SmsNotificationHandler();

			emailNotificationHandler.Successor = smsNotificationHandler;
			smsNotificationHandler.Successor = voiceNotificationHandler;

			emailNotificationHandler.Handle(receiver);

		}
	}
}
