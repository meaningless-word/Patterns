namespace State
{
	// Поведенческие паттерны

	/*
	 * Если мы реализуем шаблон State, наши объекты получают возможность менять своё поведение в зависимости от внутреннего состояния.
	 * Снаружи при этом создается впечатление, что изменился сам класс объекта.
	 * 
	 * Итак, когда используем? 
	 * Когда поведение некоторых объектов в нашей программе может динамически изменяться в зависимости от состояния.
	 * Когда вы обнаружили в коде слишком много условных конструкций, которые обрабатывают различные состояния одного объекта.
	 */

	class Program
	{
		/*
		 * Реальный пример
		 * Нам надо управлять лифтом, который может перемещаться между подвалом, первым и верхними этажами 
		 * (местоположение лифтовой кабины относительно земли будет как раз являться Состоянием, которое мы отразим в коде).
		 */
		static void Main(string[] args)
		{
			// определяется интерфейс состония лифта: IElevatorState.cs

			// Теперь реализуем различные состояния нашего объекта Лифт: LowerElevatorState.cs, GroundElevatorState.cs, UpperElevatorState.cs

			// Теперь реализация самого объекта Лифт: Elevator.cs

			// Клиентский код: 
			// инициализируем лифт (находится на земле)
			Elevator elevator = new Elevator(new GroundElevatorState());

			elevator.Up(); // подъем наверх
			elevator.Down(); // спуск на землю
			elevator.Down(); // спуск в подвал
			elevator.Down(); // ниже некуда

			/*
			 * Мы вынесли поведение, зависящее от текущего состояния объекта, в отдельные классы (соответствующие нужному состоянию).
			 * Если бы мы этого не делали, наши основные методы были бы перегружены условиями, if-else и так далее.
			 * В систему можно легко вводить новые состояния при необходимости, также как и использовать уже имеющиеся в других объектах.
			 */
		}
	}
}
