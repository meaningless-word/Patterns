namespace Observer
{
	// Поведенческие паттерны

	/*
	 * Суть паттерна Observer в том, что множество объектов могут быть потребителями информации из одного источника. 
	 * В таком случае они как раз и являются наблюдателями, подписанными на этот один ресурс. 
	 * При изменении наблюдаемого объекта автоматически происходит оповещение всех наблюдателей.
	 * 
	 * Второе название этого паттерна — Publisher-Subscriber, и он довольно часто встречается при взаимодействии распределённых систем.
	 * Когда стоит использовать? 
	 * Наша система содержит множество классов, причем состояние объектов должно быть синхронизировано.
	 * Если есть две стороны: одна из них рассылает сообщения и является главной, другая должна получать и реагировать. 
	 *   При этом логика разделена, а системы могут рассматриваться и использоваться независимо друг от друга.
	 * Если существует один объект-источник сообщений, а у него есть множество подписчиков. 
	 *   Количество последних при этом заранее неизвестно и может меняться в процессе работы программы.
	 * 
	 * Наблюдатель-подписчик может прекратить наблюдение в любой момент. После этого оба объекта смогут продолжить существовать независимо друг от друга.
	 */

	class Program
	{
		/*
		 * Создадим симулятор банковского приложения. 
		 * Попробуем написать небольшую модель биржевых торгов. 
		 * Пример сюда подходит очень хорошо, так как в этом случае у нас как раз есть объект наблюдения (курс валюты на бирже) и куча наблюдателей в лице банков и частных брокеров.
		 * Допустим, они мониторят ситуацию на бирже.
		 */

		static void Main(string[] args)
		{
			// Начнём с общего интерфейса для наблюдателя. Предусмотрим метод Update() для получения информации: IObserver.cs

			// И нам понадобится модель данных, которые наблюдатели могли бы получать с биржи. Пусть это будет курс доллара и евро в рублях: StockData.cs

			// Определим интерфейс наблюдаемого объекта (он же Publisher, то есть источник информации для наблюдателя): IObservable.cs

			// Теперь реализуем наш интерфейс IObservable. Создадим классы Bank.cs и Broker.cs, которые будут наблюдать за котировками.
			// При получении обновления через метод Update() наблюдатели будут выполнять определенные действия.

			// Теперь реализуем интерфейс нашего наблюдаемого объекта, на который подпишутся наши наблюдатели. Этим объектом будет биржа: Stock.cs

			// Теперь можно посмотреть, как это реализуется в программе: 
			Stock stock = new Stock();

			var bank = new Bank(stock);
			var broker = new Broker(stock);

			// имитация торгов
			stock.Market();
			// брокер прекращает наблюдать за торгами
			broker.StopTrade();
			// имитация торгов
			stock.Market();

			/*
			 * Это так называемая Push-модель, она довольно часто используется в архитектуре приложений, 
			 * когда существует некий канал для публикации событий (или шина событий), к которой подключены (или подписаны) потребители информации.
			 * 
			 * Альтернативой служит Pull-модель, где наблюдатели сами опрашивают источник получения информации. 
			 * В нашей ситуации эта система представляется менее эффективной.
			 */
		}
	}
}
